<!DOCTYPE html>
<html>
<head>
  <title>Relive Anxiety</title>
  <style>
    body {
      margin: 0;
      background: black;
      overflow: hidden;
      font-family: system-ui, sans-serif;
    }
    canvas {
      display: block;
      margin: auto;
    }
    #startBtn {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      padding: 20px 40px;
      font-size: 24px;
      background: rgba(255, 255, 255, 0.9);
      border: none;
      border-radius: 10px;
      cursor: pointer;
      font-weight: bold;
      z-index: 10;
    }
    #startBtn:hover {
      background: white;
    }
  </style>
</head>
<body>
<button id="startBtn">START</button>
<canvas id="c"></canvas>
<script>
const canvas = document.getElementById("c");
const ctx = canvas.getContext("2d");
const startBtn = document.getElementById("startBtn");

// Shorts resolution
canvas.width = 720;
canvas.height = 1280;

// Box - Extended down
const box = {
  x: 40,
  y: 140,
  w: canvas.width - 80,
  h: canvas.height - 200 // Changed from 280 to 200 to extend box down
};

// Ball with size variation
let ball = {
  x: box.x + box.w / 2,
  y: box.y + box.h / 2,
  vx: (Math.random() - 0.5) * 20,
  vy: (Math.random() - 0.5) * 20,
  r: 8,
  baseR: 8,
  targetR: 50,
  rTransitionSpeed: 0.01,
  hue: Math.random() * 360,
  lastCollisionTime: 0
};

// Background color shift (very slow)
let bgHue = 0;
let bgSaturation = 15;
let bgLightness = 5;

// Gravity - MUCH WEAKER
let gravityAngle = Math.random() * Math.PI * 2;
let gravityStrength = 0.08;
let time = 0;

// Load icons
const likeIcon = new Image();
likeIcon.src = "https://cdn-icons-png.flaticon.com/512/126/126473.png";
likeIcon.crossOrigin = "anonymous";

const subscribeIcon = new Image();
subscribeIcon.src = "https://cdn-icons-png.flaticon.com/512/1384/1384060.png";
subscribeIcon.crossOrigin = "anonymous";

// ðŸŽµ Calming melodic audio
let audioStarted = false;
let audioCtx, masterGain;

function playNote(frequency, duration, startTime, volume = 0.08) {
  const osc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();
  
  osc.type = "sine";
  osc.frequency.value = frequency;
  
  // Envelope for smooth note
  gain.gain.setValueAtTime(0, startTime);
  gain.gain.linearRampToValueAtTime(volume, startTime + 0.1);
  gain.gain.linearRampToValueAtTime(volume * 0.7, startTime + duration - 0.5);
  gain.gain.linearRampToValueAtTime(0, startTime + duration);
  
  osc.connect(gain);
  gain.connect(masterGain);
  
  osc.start(startTime);
  osc.stop(startTime + duration);
}

function playMelody() {
  const now = audioCtx.currentTime;
  
  // Calming pentatonic scale melody (C major pentatonic)
  const notes = [
    { freq: 261.63, duration: 2 },    // C4
    { freq: 293.66, duration: 1.5 },  // D4
    { freq: 329.63, duration: 2.5 },  // E4
    { freq: 293.66, duration: 1 },    // D4
    { freq: 392.00, duration: 3 },    // G4
    { freq: 329.63, duration: 2 },    // E4
    { freq: 440.00, duration: 2.5 },  // A4
    { freq: 392.00, duration: 1.5 },  // G4
    { freq: 329.63, duration: 4 },    // E4
  ];
  
  let timeOffset = 0;
  notes.forEach(note => {
    playNote(note.freq, note.duration, now + timeOffset, 0.06);
    timeOffset += note.duration;
  });
  
  setTimeout(() => {
    if (audioStarted) playMelody();
  }, (timeOffset + 3) * 1000);
}

function playBackgroundChord() {
  const chordFreqs = [130.81, 164.81, 196.00];
  
  chordFreqs.forEach(freq => {
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    
    osc.type = "sine";
    osc.frequency.value = freq;
    gain.gain.setValueAtTime(0, audioCtx.currentTime);
    gain.gain.linearRampToValueAtTime(0.015, audioCtx.currentTime + 3);
    
    osc.connect(gain);
    gain.connect(masterGain);
    osc.start();
  });
}

function startAudio() {
  if (audioStarted) return;
  audioStarted = true;
  
  startBtn.style.display = 'none';
  
  audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  masterGain = audioCtx.createGain();
  masterGain.gain.value = 1;
  masterGain.connect(audioCtx.destination);
  
  playBackgroundChord();
  
  setTimeout(() => {
    playMelody();
  }, 2000);
}

startBtn.addEventListener("click", startAudio);

// Change ball size target
function changeSize() {
  ball.targetR = 5 + Math.random() * 95;
}

changeSize();
setInterval(changeSize, 5000);

function drawBorder() {
  ctx.strokeStyle = "white";
  ctx.lineWidth = 3;
  ctx.strokeRect(box.x, box.y, box.w, box.h);
}

function drawText() {
  ctx.fillStyle = "white";
  ctx.textAlign = "center";
  ctx.font = "bold 44px sans-serif";
  
  // Measure text to position icons beside it
  const titleText = "STAY HERE";
  const titleWidth = ctx.measureText(titleText).width;
  const titleX = canvas.width / 2;
  const titleY = 60;
  
  // Draw title
  ctx.fillText(titleText, titleX, titleY);
  
  // Draw like icon to the left of title (with filter to make it white)
  if (likeIcon.complete) {
    ctx.save();
    
    // Create a temporary canvas to apply filter
    const tempCanvas = document.createElement('canvas');
    tempCanvas.width = 35;
    tempCanvas.height = 35;
    const tempCtx = tempCanvas.getContext('2d');
    
    // Draw image
    tempCtx.drawImage(likeIcon, 0, 0, 35, 35);
    
    // Apply white filter by using composite operations
    tempCtx.globalCompositeOperation = 'source-in';
    tempCtx.fillStyle = 'white';
    tempCtx.fillRect(0, 0, 35, 35);
    
    // Draw the filtered image
    ctx.drawImage(tempCanvas, titleX - titleWidth/2 - 50, titleY - 35);
    ctx.restore();
  }
  
  // Draw subscribe icon to the right of title
  if (subscribeIcon.complete) {
    ctx.drawImage(subscribeIcon, titleX + titleWidth/2 + 15, titleY - 35, 35, 35);
  }
  
  // Draw subtitle
  ctx.font = "28px sans-serif";
  ctx.fillText("TO RELIVE ANXIETY", canvas.width / 2, 100);
}

function handleCollision() {
  // Only change color if enough time has passed since last collision
  const now = Date.now();
  if (now - ball.lastCollisionTime > 100) {
    ball.hue += 40;
    ball.lastCollisionTime = now;
  }
}

function loop() {
  requestAnimationFrame(loop);
  time += 0.01;
  
  // Very slow background color shift
  bgHue += 0.05;
  if (bgHue >= 360) bgHue = 0;
  
  // Interpolate ball size toward target
  ball.r += (ball.targetR - ball.r) * ball.rTransitionSpeed;
  
  // Draw background with slowly changing color
  ctx.fillStyle = `hsl(${bgHue}, ${bgSaturation}%, ${bgLightness}%)`;
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  
  // Soft trail fade
  ctx.fillStyle = `hsla(${bgHue}, ${bgSaturation}%, ${bgLightness}%, 0.20)`;
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  
  // Gravity pulses + rotates - MUCH GENTLER
  gravityAngle += Math.sin(time * 0.7) * 0.005;
  gravityStrength = 0.08 + Math.sin(time * 0.9) * 0.04;
  const gx = Math.cos(gravityAngle) * gravityStrength;
  const gy = Math.sin(gravityAngle) * gravityStrength;
  ball.vx += gx;
  ball.vy += gy;
  ball.x += ball.vx;
  ball.y += ball.vy;
  
  // Wall collisions with better handling
  let collided = false;
  
  if (ball.x - ball.r < box.x) {
    ball.x = box.x + ball.r;
    ball.vx *= -0.92;
    collided = true;
  }
  if (ball.x + ball.r > box.x + box.w) {
    ball.x = box.x + box.w - ball.r;
    ball.vx *= -0.92;
    collided = true;
  }
  if (ball.y - ball.r < box.y) {
    ball.y = box.y + ball.r;
    ball.vy *= -0.92;
    collided = true;
  }
  if (ball.y + ball.r > box.y + box.h) {
    ball.y = box.y + box.h - ball.r;
    ball.vy *= -0.92;
    collided = true;
  }
  
  if (collided) {
    handleCollision();
  }
  
  // Light air resistance
  ball.vx *= 0.999;
  ball.vy *= 0.999;
  
  // Very gentle speed creep
  ball.vx *= 1.0003;
  ball.vy *= 1.0003;
  
  // Speed limits
  ball.vx = Math.max(-18, Math.min(18, ball.vx));
  ball.vy = Math.max(-18, Math.min(18, ball.vy));
  
  // If ball gets too slow, give it a nudge
  const speed = Math.sqrt(ball.vx * ball.vx + ball.vy * ball.vy);
  if (speed < 3) {
    ball.vx += (Math.random() - 0.5) * 3;
    ball.vy += (Math.random() - 0.5) * 3;
  }
  
  // Glow
  ctx.shadowBlur = 30;
  ctx.shadowColor = `hsl(${ball.hue}, 100%, 60%)`;
  ctx.fillStyle = `hsl(${ball.hue}, 100%, 60%)`;
  ctx.beginPath();
  ctx.arc(ball.x, ball.y, ball.r, 0, Math.PI * 2);
  ctx.fill();
  ctx.shadowBlur = 0;
  drawBorder();
  drawText();
}
loop();
</script>
</body>
</html>
